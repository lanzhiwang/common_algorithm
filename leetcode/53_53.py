#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
53. 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。


[-2, 1, -3, 4, -1, 2, 1, -5, 4]
  0  1   2  3   4  5  6   7  8

opt(8)
    [8]
    [7, 8]
    [6, 7, 8]
    [5, 6, 7, 8]
    [4, 5, 6, 7, 8]
    [3, 4, 5, 6, 7, 8]
    [2, 3, 4, 5, 6, 7, 8]
    [1, 2, 3, 4, 5, 6, 7, 8]
    [0, 1, 2, 3, 4, 5, 6, 7, 8]
    opt(7)

opt(7)
    [7]
    [6, 7]
    [5, 6, 7]
    [4, 5, 6, 7]
    [3, 4, 5, 6, 7]
    [2, 3, 4, 5, 6, 7]
    [1, 2, 3, 4, 5, 6, 7]
    [0, 1, 2, 3, 4, 5, 6, 7]
    opt(6)


opt(6)
    [6]
    [5, 6]
    [4, 5, 6]
    [3, 4, 5, 6]
    [2, 3, 4, 5, 6]
    [1, 2, 3, 4, 5, 6]
    [0, 1, 2, 3, 4, 5, 6]
    opt(5)


opt(5)
    [5]
    [4, 5]
    [3, 4, 5]
    [2, 3, 4, 5]
    [1, 2, 3, 4, 5]
    [0, 1, 2, 3, 4, 5]
    opt(4)


opt(4)
    [4]
    [3, 4]
    [2, 3, 4]
    [1, 2, 3, 4]
    [0, 1, 2, 3, 4]
    opt(3)


opt(3)
    [3]
    [2, 3]
    [1, 2, 3]
    [0, 1, 2, 3]
    opt(2)


opt(2)
    [2]
    [1, 2]
    [0, 1, 2]
    opt(1)


opt(1)
    [1]
    [0, 1]
    opt(0)  return 0


opt(0)
    [0]  return -2
    0
    return 0




"""



